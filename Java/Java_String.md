# Java 文字列

* imutable  
String クラス
* mutable  
StringBuilder クラス

## Java の文字

UTF-16 で表現(1 文字 2 byte)  
char 型の範囲もこれに合わせて 0 ~ 65535

サロゲートペアは？(32 bit)  
"文字"と"コードポイント"で概念が存在する。  
"文字" は char 型で表現できる範囲(16 bit)を指す。  
"コードポイント"は Unicode 文字に対応する概念で、Int型で表現。  
→String.indexOf の引数が Int なのはこういった理由から  
日常的には漢字などを使うことがないので 16bit 長のコードポイントで事足りる。

## 初期化

以下は実は String オブジェクトの生成が 2 回行われている。

```java:sample.java
String s = new String("abc")
```

Java ではリテラル "abc" は String 型のオブジェクトに置換される。
つまり `new String` と `"abc"` で 2回のオブジェクト生成がされていることになる。　　

## 文字列結合

Java では文字列結合に + 演算子が使用できる。

```java:sample.java
String s = "abc"
s += "def"
```

この += 演算子は内部的には StringBuilder クラスに置換されて最終的に toString() メソッドで String 型に置き換えられている。
ループの中で += 演算子で結合させまくると・・・  
パフォーマンスに影響が出てくるのは容易に想像ができる。
この場合 StringBuilder クラスを事前に定義しておいて結合していく方がよいだろう。

## 比較

`==` で比較するのは同一性であって、同値性ではない。
同じ文字列を指すオブジェクトでも参照先が異なれば真にはならない。
ただし、リテラル文字の場合は同じ参照先を指すようになるので真となる点には注意が必要。
まぁとにかく String.equals() をつかえばよい。

## バイト文字

バイト列を扱うには byte型の配列を作成するが、これは動的にサイズを変更できない。  
長さを変えたい場合は ByteArrayOutputStream を使う。  

バイトと文字を同一視するのは他言語では一般的(ASCII は 7bit で表現できる)。  
だが Java では禁止(UTF-16)。  
byte 型配列と文字を相互に変換したい場合はエンコーディング方式を指定して行う。  
指定しない場合はシステムの文字エンコーディング方式に依存する。  

