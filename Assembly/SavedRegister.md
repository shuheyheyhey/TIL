# Caller/Calle Saved Register

## Caller Saved Register
呼び出し元が保持しておくべきレジスタ
r0 ~ r9 がそれにあたる

## Calle Saved Register
呼び出された側が保持すべきレジスタ
fp(フレームポインタ) sp ip pc がこれに当たる 

## 関数のプロローグとエピローグ  

### プロローグ
[参考 1](http://masahir0y.blogspot.jp/2012/04/blog-post.html)  
[参考 2](https://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%BC%E3%83%AB%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF)   
アセンブラの関数の冒頭にはスタックを伸ばして追加して、レジスタの値を退避させているような処理がある。  
例として、以下はある関数のエントリ部分に記載されているもので、
sp(スタックポインタ) を `0x90` 伸ばして、そこに各レジスタの値を退避させていることがわかる。

```
　sub        sp, sp, #0x90
　stp        x20, x19, [sp, #0x70]
　stp        x29, x30, [sp, #0x80]
　add        x29, sp, #0x80
　mov        x19, x0
```

### エピローグ

上記のプロローグで sp に退避させたものをレジスタに戻している。

```
　ldp        x29, x30, [sp, #0x80]
　ldp        x20, x19, [sp, #0x70]
　add        sp, sp, #0x90
　ret
```

※ x29 は fp(フレームポインタ) で x30 は lr(リンクレジスタ)

## まとめ

関数の呼び出しが多くなるとエピローグ、プロローグがオーバーヘッドになってくる。
インライン化できる箇所などは積極的にそうするようにして、オーバーヘッドをなくす。  
→Swift では何ができるだろう？