# Java 数値(整数)

## リテラル

L または l の表記があるリテラルは long 型で、その他は int 型となる。　　

* `1`  
Int 型のリテラル表現
* `1L`  
long 型のリテラル表現

型の最大サイズを超えるリテラル表現はコンパイルエラーとなる。  
例えば  

```
if(n < 2147482648) { // コンパイル不可

}

if(n < 2147482648L) { // コンパイル可能

}
```

## 基数

普通にリテラルを書けば 10 進数となる。  
以下の表現も可能。  

```
0b11 //2進数
07 //8進数
0xFF //16進数
```

## 数値と文字の変換

`char zero = '0';` は 0x30 になる。  
そのまま数値として扱うことはもちろん可能。  
じゃ '0' を 数値 0 として扱いたい場合は？  
Charcter.digit を使用する。  

```
int i =  Charcter.digit('0', 10); // 文字から数値
char c = Charcter.forDigit(0, 10); // 数値から文字
```

## 演算

特に珍しいことはない。  
0 で除算したときには ArithmeticException が発生する。  

桁あふれは当然 Java でも起こることがある。  
long 型よりさらに大きな値を扱いたい場合は BigInteger や BigDecimal を使う。  

## 型変換

代入時に代入先と元の型の違いによって型の変換が発生する。  
long 型に int 型を代入すると long 型に昇格される(拡大変換)。  
int 型に long 型を代入するとコンパイルエラーが発生する(縮小変換)。  

### キャスト

表現できるとしても縮小変換がだめなのか？  
この場合はキャストを使う。  
キャストすれば縮小変換を強制できる。  
万が一桁あふれがあるとオーバーフローが発生し、ラップする。

数値から boolean のキャストや数値から String へのキャストはコンパイルエラーになる。  

### 演算時の型変換

演算時に昇格がされないとオーバーフロー等で正しい値が得られないことがある。 

* short, byte, char の演算は int 型への昇格が行われる。  
* 演算対象の一方に long 型が存在すれば long 型に昇格される。  

```
short s1 = 1;
short s2 = 2;
short s3 = s1 + s2; // コンパイルエラー
short s3 = (short)(s1 + s2) // コンパイル可能
```
 
リテラルの場合は特殊で、キャストを行わなくても代入可能となっている。
もちろん、代入先の型の範囲を超える場合はコンパイルエラーとなる。

```
byte b = 127;
char c = 65535;
```

メソッドの引数へのリテラル表現はキャストが必要になるので注意。  

```
void exit(char c) {
}

exit(1); // int 型解釈でコンパイルエラー
exit((char)1); // コンパイル可能
```


